// Pavel Penkov 2025 All Rights Reserved.


#include "UHLDebugSystemSubsystem.h"

#include "Logging/LogMacros.h"
#include "GameFramework/Pawn.h"
#include "GameFramework/Controller.h"
#include "GameFramework/PlayerController.h"
#include "Development/UHLDebugSystemSettings.h"
#include "UHLDebugSystemTypes.h"
#include "UHLDebugSystemBuildUtils.h"
#if WITH_EDITOR
#include "Framework/Notifications/NotificationManager.h"
#include "Widgets/Notifications/SNotificationList.h"
#endif

#include UE_INLINE_GENERATED_CPP_BY_NAME(UHLDebugSystemSubsystem)

UUHLDebugSystemSubsystem::UUHLDebugSystemSubsystem()
{
}

void UUHLDebugSystemSubsystem::Initialize(FSubsystemCollectionBase& Collection)
{
    Super::Initialize(Collection);

	if (bSetupped) return;
	bSetupped = true;
	UE_LOG(LogTemp, Warning, TEXT("[UUHLDebugSubsystem::Initialize] Start"));

	const UUHLDebugSystemSettings* DeveloperSettings = GetDefault<UUHLDebugSystemSettings>();
	DebugCategories = DeveloperSettings->DebugCategories;

	// If no categories require pawn, mark as setup to avoid waiting forever.
	const bool bAnyRequiresPawn = DebugCategories.ContainsByPredicate([](const FUHLDebugCategory& Category)
	{
		return Category.bRequiresPlayerPawnToEnable;
	});
	if (!bAnyRequiresPawn)
	{
		bSetUpCategoriesThatRequiresPlayerPawn = true;
	}

	for (const TTuple<FGameplayTag, bool>& EnabledDebugCategory : DeveloperSettings->EnabledDebugCategories)
	{
		const FUHLDebugCategory* UHLDebugCategory = DebugCategories.FindByPredicate([=](const FUHLDebugCategory& DebugCategory)
		{
			return DebugCategory.Tags.HasAnyExact(FGameplayTagContainer(EnabledDebugCategory.Key));
		});
		if (EnabledDebugCategory.Value == true && UHLDebugCategory != nullptr && !UHLDebugCategory->bRequiresPlayerControllerToEnable)
		{
			EnableDebugCategory(EnabledDebugCategory.Key, EnabledDebugCategory.Value);
		}
	};

EUHLDebugSystemBuildType BuildType = GetCurrentUHLBuildType();
if (BuildType != EUHLDebugSystemBuildType::Editor)
	{
		UE_LOG(LogTemp, Warning, TEXT("[UUHLDebugSubsystem::Initialize] BuildType not editor so check DebugCategories that should be enabled"));
		for (const FUHLDebugCategory& DebugCategory : DebugCategories)
		{
			UE_LOG(LogTemp, Warning, TEXT("[UUHLDebugSubsystem::Initialize] EnableDebugCategory %s"), *DebugCategory.Tags.First().ToString());
            if (DebugCategory.ByDefaultEnabledInBuildTypes.Contains(BuildType))
			{
				EnableDebugCategory(DebugCategory.Tags.First(), true);
			}
		}
	}
	UE_LOG(LogTemp, Warning, TEXT("[UUHLDebugSubsystem::SetUp] Finish"));

	FWorldDelegates::OnPostWorldInitialization.AddUObject(this, &ThisClass::OnPostWorldInit);
	FWorldDelegates::OnWorldBeginTearDown.AddUObject(this, &ThisClass::OnWorldBeginTearDown);

	// If a PlayerController is already present (e.g., early startup or seamless travel),
	// run setup immediately so PC/Pawn-required categories don't miss their activation window.
	if (UWorld* World = GetWorld())
	{
		const bool bReady = TrySetupPlayerRequirements();
		if (!bReady)
		{
			StartSetupRetryTimer();
		}
	}
}

void UUHLDebugSystemSubsystem::Deinitialize()
{
	FWorldDelegates::OnPostWorldInitialization.RemoveAll(this);
	StopSetupRetryTimer();

	if (UWorld* World = GetWorld())
	{
		if (ActorSpawnedDelegateHandle.IsValid())
		{
			World->RemoveOnActorSpawnedHandler(ActorSpawnedDelegateHandle);
		}
	}
	
    for (FUHLDebugCategory& DebugCategory : DebugCategories)
    {
        // if (DebugCategory.bForceComponentsDeactivateOnEnd)
        if (DebugCategory.GetIsEnabled())
        {
            DebugCategory.TryDisable(this);
        }
    }
	
    Super::Deinitialize();
}

void UUHLDebugSystemSubsystem::OnActorSpawned(AActor* SpawnedActor)
{
	const bool bReady = TrySetupPlayerRequirements();
	if (!bReady)
	{
		StartSetupRetryTimer();
	}
}

bool UUHLDebugSystemSubsystem::TrySetupPlayerRequirements()
{
	UWorld* World = GetWorld();
	if (!World)
	{
		return false;
	}

	APlayerController* PC = World->GetFirstPlayerController();
	if (PC && !bSetUpCategoriesThatRequiresPlayerController)
	{
		SetUpCategoriesThatRequiresPlayerController();
	}

	APawn* Pawn = PC ? PC->GetPawn() : nullptr;
	// wait until pawn finished BeginPlay to avoid accessing uninitialized components
	if (Pawn && Pawn->HasActorBegunPlay() && !bSetUpCategoriesThatRequiresPlayerPawn)
	{
		SetUpCategoriesThatRequiresPlayerPawn();
	}

	const bool bReady = bSetUpCategoriesThatRequiresPlayerController && bSetUpCategoriesThatRequiresPlayerPawn;
	if (bReady)
	{
		StopSetupRetryTimer();
		if (ActorSpawnedDelegateHandle.IsValid())
		{
			World->RemoveOnActorSpawnedHandler(ActorSpawnedDelegateHandle);
			ActorSpawnedDelegateHandle.Reset();
		}
	}
	return bReady;
}

void UUHLDebugSystemSubsystem::StartSetupRetryTimer()
{
	if (SetupRetryTimerHandle.IsValid()) return;
	if (UWorld* World = GetWorld())
	{
		World->GetTimerManager().SetTimer(SetupRetryTimerHandle, this, &UUHLDebugSystemSubsystem::OnSetupRetryTimer, 0.25f, true);
	}
}

void UUHLDebugSystemSubsystem::StopSetupRetryTimer()
{
	if (SetupRetryTimerHandle.IsValid())
	{
		if (UWorld* World = GetWorld())
		{
			World->GetTimerManager().ClearTimer(SetupRetryTimerHandle);
		}
		SetupRetryTimerHandle.Invalidate();
	}
}

void UUHLDebugSystemSubsystem::OnSetupRetryTimer()
{
	TrySetupPlayerRequirements();
}

void UUHLDebugSystemSubsystem::SetUpCategoriesThatRequiresPlayerController()
{
    if (bSetUpCategoriesThatRequiresPlayerController) return;
    UE_LOG(LogTemp, Warning, TEXT("[UUHLDebugSubsystem::SetUpCategoriesThatRequiresPlayerController] Start"));
    bSetUpCategoriesThatRequiresPlayerController = true;

    const UUHLDebugSystemSettings* DeveloperSettings = GetDefault<UUHLDebugSystemSettings>();

    for (const TTuple<FGameplayTag, bool>& EnabledDebugCategory : DeveloperSettings->EnabledDebugCategories)
    {
        const FUHLDebugCategory* UHLDebugCategory = DebugCategories.FindByPredicate([=](const FUHLDebugCategory& DebugCategory)
        {
            return DebugCategory.Tags.HasAnyExact(FGameplayTagContainer(EnabledDebugCategory.Key));
        });
        if (EnabledDebugCategory.Value == true && UHLDebugCategory != nullptr && UHLDebugCategory->bRequiresPlayerControllerToEnable)
        {
            EnableDebugCategory(EnabledDebugCategory.Key, EnabledDebugCategory.Value);
        }
    };

	// activate debug categories that "bSetUpCategoriesThatRequiresPlayerController" and should be enabled in BuildType
EUHLDebugSystemBuildType BuildType = GetCurrentUHLBuildType();
if (BuildType != EUHLDebugSystemBuildType::Editor)
	{
		UE_LOG(LogTemp, Warning, TEXT("[UUHLDebugSubsystem::SetUpCategoriesThatRequiresPlayerController] BuildType not editor so check DebugCategories that should be enabled"));
		for (const FUHLDebugCategory& DebugCategory : DebugCategories)
		{
			if (DebugCategory.ByDefaultEnabledInBuildTypes.Contains(BuildType))
			{
				UE_LOG(LogTemp, Warning, TEXT("[UUHLDebugSubsystem::SetUpCategoriesThatRequiresPlayerController] EnableDebugCategory %s"), *DebugCategory.Tags.First().ToString());
				EnableDebugCategory(DebugCategory.Tags.First(), true);
			}
		}
	}

	bIsSetuping = false;
	UE_LOG(LogTemp, Warning, TEXT("[UUHLDebugSubsystem::SetUpCategoriesThatRequiresPlayerController] Finish"));
}

void UUHLDebugSystemSubsystem::SetUpCategoriesThatRequiresPlayerPawn()
{
	if (bSetUpCategoriesThatRequiresPlayerPawn) return;

	// Early out if no categories require pawn: mark as done.
	const bool bAnyRequiresPawn = DebugCategories.ContainsByPredicate([](const FUHLDebugCategory& Category)
	{
		return Category.bRequiresPlayerPawnToEnable;
	});
	if (!bAnyRequiresPawn)
	{
		bSetUpCategoriesThatRequiresPlayerPawn = true;
		return;
	}

	// Require a valid player pawn before proceeding.
	APawn* PlayerPawn = nullptr;
	if (UWorld* World = GetWorld())
	{
		if (APlayerController* PC = World->GetFirstPlayerController())
		{
			PlayerPawn = PC->GetPawn();
		}
	}
	if (!PlayerPawn)
	{
		return; // Wait for pawn spawn; delegate will retry.
	}

	UE_LOG(LogTemp, Warning, TEXT("[UUHLDebugSubsystem::SetUpCategoriesThatRequiresPlayerPawn] Start"));
	bSetUpCategoriesThatRequiresPlayerPawn = true;

	const UUHLDebugSystemSettings* DeveloperSettings = GetDefault<UUHLDebugSystemSettings>();

	for (const TTuple<FGameplayTag, bool>& EnabledDebugCategory : DeveloperSettings->EnabledDebugCategories)
	{
		const FUHLDebugCategory* UHLDebugCategory = DebugCategories.FindByPredicate([=](const FUHLDebugCategory& DebugCategory)
		{
			return DebugCategory.Tags.HasAnyExact(FGameplayTagContainer(EnabledDebugCategory.Key));
		});
		if (EnabledDebugCategory.Value == true && UHLDebugCategory != nullptr && UHLDebugCategory->bRequiresPlayerPawnToEnable)
		{
			EnableDebugCategory(EnabledDebugCategory.Key, EnabledDebugCategory.Value);
		}
	};

	EUHLDebugSystemBuildType BuildType = GetCurrentUHLBuildType();
	if (BuildType != EUHLDebugSystemBuildType::Editor)
	{
		for (const FUHLDebugCategory& DebugCategory : DebugCategories)
		{
			if (DebugCategory.ByDefaultEnabledInBuildTypes.Contains(BuildType) && DebugCategory.bRequiresPlayerPawnToEnable)
			{
				EnableDebugCategory(DebugCategory.Tags.First(), true);
			}
		}
	}

	bIsSetuping = false;
	UE_LOG(LogTemp, Warning, TEXT("[UUHLDebugSubsystem::SetUpCategoriesThatRequiresPlayerPawn] Finish"));
}

bool UUHLDebugSystemSubsystem::IsCategoryEnabled(const FGameplayTag DebugCategoryTag) const
{
    const FUHLDebugCategory* UHLDebugCategory = DebugCategories.FindByPredicate([=](const FUHLDebugCategory& DebugCategory)
    {
        return DebugCategory.Tags.HasAnyExact(FGameplayTagContainer(DebugCategoryTag));
    });
    if (UHLDebugCategory != nullptr)
    {
        return UHLDebugCategory->GetIsEnabled();
    }
    return false;
}

void UUHLDebugSystemSubsystem::EnableDebugCategory(const FGameplayTag DebugCategoryTag, bool bEnable)
{
    bool bEnabled = bEnable;

    FUHLDebugCategory* UHLDebugCategory = DebugCategories.FindByPredicate([=](const FUHLDebugCategory& DebugCategory)
    {
        return DebugCategory.Tags.HasAnyExact(FGameplayTagContainer(DebugCategoryTag));
    });
    if (UHLDebugCategory == nullptr) return;
    if (UHLDebugCategory->bRequiresPlayerControllerToEnable && !bSetUpCategoriesThatRequiresPlayerController) return;
    if (UHLDebugCategory->bRequiresPlayerPawnToEnable)
    {
        APawn* Pawn = nullptr;
        if (UWorld* World = GetWorld())
        {
            if (APlayerController* PC = World->GetFirstPlayerController())
            {
                Pawn = PC->GetPawn();
            }
        }
        if (!Pawn)
        {
            return;
        }
    }
    if (UHLDebugCategory->GetIsEnabled() && bEnable) return;
    if (!UHLDebugCategory->GetIsEnabled() && !bEnable) return;

    if (bEnable)
    {
        // Disable blocked DebugCategories
        for (const FUHLDebugCategory& DebugCategory : DebugCategories)
        {
            if (DebugCategory != *UHLDebugCategory
            	&& !UHLDebugCategory->Blocks.IsEmpty()
                && DebugCategory.Tags.HasAny(UHLDebugCategory->Blocks))
            {
                EnableDebugCategory(DebugCategory.Tags.First(), false);
            }
        }

    	// Enable required DebugCategories
    	for (const FUHLDebugCategory& DebugCategory : DebugCategories)
    	{
    		if (DebugCategory != *UHLDebugCategory
				&& !UHLDebugCategory->RequiredDebugCategories.IsEmpty()
				&& DebugCategory.Tags.HasAny(UHLDebugCategory->RequiredDebugCategories))
    		{
    			EnableDebugCategory(DebugCategory.Tags.First(), true);
    		}
    	}

        bEnabled = UHLDebugCategory->TryEnable(this);
    }
    else
    {
        if (!bIsSetuping)
        // TODO remove
            // || (bIsSetuping && UHLDebugCategory->bForceComponentsDeactivateOnEnd))
        {
        	// Check that its not required by some other DebugCategory
        	bool bHasDependantDebugCategory = false;
        	FUHLDebugCategory DependantDebugCategory;
        	for (const FUHLDebugCategory& DebugCategory : DebugCategories)
        	{
        		if (DebugCategory != *UHLDebugCategory
					&& !DebugCategory.RequiredDebugCategories.IsEmpty()
					&& DebugCategory.RequiredDebugCategories.HasAny(UHLDebugCategory->Tags))
        		{
        			bHasDependantDebugCategory = true;
        			DependantDebugCategory = DebugCategory;
        			// EnableDebugCategory(DebugCategory.Tags.First(), true);
        		}
        	}
        	if (bHasDependantDebugCategory)
        	{
        		DependantDebugCategory.TryDisable(this);

        		#if WITH_EDITOR
					// Create the notification info
        			FText ToastText = FText::Format(FTextFormat::FromString(TEXT("UHLDebugSystem: Dependant DebugCategory {0} also disabled")), FText::FromString(DependantDebugCategory.Name));
					FNotificationInfo Info(ToastText);
					Info.bFireAndForget = true;         // auto‑expire
					Info.FadeOutDuration = 0.5f;        // smooth fade
					Info.ExpireDuration = 5.0f;         // seconds on‑screen
					Info.bUseThrobber = false;          // no spinning icon
					Info.bUseLargeFont = false;         
					Info.bUseSuccessFailIcons = false;  // we’ll show a warning icon manually
		
					// Optionally give it a warning icon on the left:
					static const FName WarningIconName = TEXT("Icons.Warning"); 
					Info.Image = FCoreStyle::Get().GetBrush(WarningIconName);
		
					// Fire it off
					FSlateNotificationManager::Get().AddNotification(Info);
        		#endif
        	}
        	
            UHLDebugCategory->TryDisable(this);
        }
    }

    for (FGameplayTag GameplayTag : UHLDebugCategory->Tags.GetGameplayTagArray())
    {
        OnDebugCategoryChanged.Broadcast(GameplayTag, bEnabled);
    }
}

void UUHLDebugSystemSubsystem::ToggleDebugCategory(const FGameplayTag DebugCategoryTag)
{
    EnableDebugCategory(DebugCategoryTag, !IsCategoryEnabled(DebugCategoryTag));
}

const FUHLDebugCategory& UUHLDebugSystemSubsystem::GetDebugCategoryByTag(const FGameplayTag DebugCategoryTag) const
{
	const FUHLDebugCategory* UHLDebugCategory = DebugCategories.FindByPredicate([=](const FUHLDebugCategory& DebugCategory)
	{
		return DebugCategory.Tags.HasAnyExact(FGameplayTagContainer(DebugCategoryTag));
	});
	return *UHLDebugCategory;
}

void UUHLDebugSystemSubsystem::OnPostWorldInit(UWorld* InWorld, const UWorld::InitializationValues IVS)
{
	if (InWorld->IsGameWorld())
	{
		const bool bReady = TrySetupPlayerRequirements();

		if (!bReady)
		{
			FOnActorSpawned::FDelegate ActorSpawnedDelegate = FOnActorSpawned::FDelegate::CreateUObject(this, &UUHLDebugSystemSubsystem::OnActorSpawned);
			ActorSpawnedDelegateHandle = InWorld->AddOnActorSpawnedHandler(ActorSpawnedDelegate);
			StartSetupRetryTimer();
		}
	}
}

void UUHLDebugSystemSubsystem::OnWorldBeginTearDown(UWorld* World)
{
	World->RemoveOnActorSpawnedHandler(ActorSpawnedDelegateHandle);
	StopSetupRetryTimer();
}